    public void processCSV(String inputFilePath, MeMEngine engine, String indexName)
        throws IOException {
        String line;
        Map<String, String> dataMap = new HashMap<>();
        SkipList sl = new SkipList(0.5);
        SSTableList ss = new SSTableList();

        try ( var br = Files.newBufferedReader(Paths.get(inputFilePath))) {
            int counter = 0;
            br.readLine();

            while ((line = br.readLine()) != null) {

                String[] columns = line.split(",");
                if (columns.length >= 3) {
                    if (sl.getSize() >= ss.getTriggerSize()) {
                        ss.write(sl, dbName + "_" + counter + ".db");
                        ss = new SSTableList();
                        sl = new SkipList(0.5);
                        counter += 1;
                    }
                    sl.insert(new InsertCommand(columns[0],columns[1] + "," + columns[2]));

                    //engine.put(columns[0], columns[1] + columns[2], counter, indexName);
                }
            }


        } catch (IOException e) {
            e.printStackTrace();
        }
    }




  public void writeMeta(String dbName,List<String> fileNames, int kvNums, String metaName, Boolean update) {
    // length + dbName + fileNames.size + kvNums + blockSize(int) + filenames(multi)
    // kvnumbs should be added in the top level
    File f = new File(dataDirectory, metaName);
    try (RandomAccessFile file = new RandomAccessFile(f.getAbsolutePath(), "rw")) {
      if (update)
        file.seek(file.length()); // Move the pointer to the end of the file
      String version = getCurrentTimestamp();
      file.writeInt(version.length());
      file.writeBytes(version);
      // Writing the length of dbName
      file.writeInt(dbName.length());
      // Writing the dbName itself
      file.writeBytes(dbName);
      // Writing the totalSize in MB
      file.writeInt(fileNames.size());
      // Writing kvNums
      file.writeInt(kvNums);
      // Writing blockSize (you might choose to use or not use this directly)
      file.writeInt(BLOCK_SIZE);
      // Writing each filename followed by a newline character for separation
      for (String fileName : fileNames) {
        file.writeInt(fileName.length());
        file.writeBytes(fileName); // Using "\n" to separate filenames
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public Map<String,Object> readMeta(String metaName) {
    File f = new File(dataDirectory, metaName);
    try (RandomAccessFile file = new RandomAccessFile(f.getAbsolutePath(), "r")) {
      Map<String,Object> map = new HashMap<>();
      Map<String,Object> info = new HashMap<>();
      while (file.getFilePointer() < file.length()) {
        // reading time stamp
        int versionL = file.readInt();
        byte[] versionB = new byte[versionL];
        file.read(versionB);
        String version = new String(versionB);
        // Reading the length of dbName and then the dbName itself
        int dbNameLength = file.readInt();
        byte[] dbNameBytes = new byte[dbNameLength];
        file.read(dbNameBytes);
        String dbName = new String(dbNameBytes);
        // Reading the size of fileNames and kvNums
        int fileNamesSize = file.readInt();
        int kvNums = file.readInt();
        int blockSize = file.readInt();
        // Reading filenames
        List<String> fileNames = new ArrayList<>();
        for (int i = 0; i < fileNamesSize; i++) {
          int fileNameLength = file.readInt(); // Reading the length of the filename
          byte[] fileNameBytes = new byte[fileNameLength];
          file.read(fileNameBytes);
          String fileName = new String(fileNameBytes);
          fileNames.add(fileName);
        }
        info.put("size",fileNamesSize); info.put("kvNums",kvNums);
        info.put("blocks",blockSize); info.put("fileNames", fileNames);
        info.put("version",version);

        map.put(dbName,info);
        // Print the read data
        printMeta(dbName, fileNames, kvNums, blockSize, version);

      }
      return map;
    } catch (IOException e) {
      e.printStackTrace();
    }
    return null;
  }

    public Map<String,Object> delBasic(String key, String idxName, String operation, String value) {
    Map<String, Object> info = new HashMap<>();
    String fileName = searchIndex(key, idxName);


    if (fileName == null || fileName.isEmpty()) {
      return null;
    }
    if (value == null && operation.equals("insert")) return null;
    File f = new File(dataDirectory, fileName);
    try (RandomAccessFile file = new RandomAccessFile(f.getAbsolutePath(), "r")) {
      SSTableList ss = new SSTableList();
      Map head = ss.readHeadBlock(file);

      int blockIndex = search((List<String>) head.get("UsedBlockFirstKeys"), Integer.parseInt(key));

      if (!operation.equals("insert") && blockIndex == -1) {
        System.out.println("Data Not Found");
        return null;
      }
      if (!operation.equals("insert")) {
        List<List<Command>> data = ss.readDataBlocks(file);
        List<Command> commands = data.get(blockIndex);
        for (Command c : commands) {
          if (c.getKey().equals(key)) {
            if (c.getValue().equals("null") && operation.equals("delete")){
              System.out.println("Data Has Been Deleted");
              return null;
            }
            ss.handleOperation(c, operation, value);
            break;
          }
        }
        info.put("fileName",fileName); info.put("data", data);
      }
      if (operation.equals("insert")){
        List<List<Command>> data = ss.readDataBlocks(file);
        if (blockIndex != -1){
          List<Command> commands = data.get(blockIndex);
          for (Command c : commands) {
            if (c.getKey().equals(key)) {
              promptForValue(c,value);
            }
          }

        }
        Map<String, Object> headBlock = ss.readHeadBlock(file);
        ss.usedBlocks = (int) headBlock.get("UsedBlocksCount");
        info.put("fileName",headBlock.get("FileName")); info.put("data",data);
      }
      return info;
    } catch (Exception e) {
      e.printStackTrace();
      return null;
    }
  }

  private void handleOperation(Command command, String operation, String value) {
    switch (operation) {
      case "delete":
        command.setValue("null");
        break;
      case "set":
        command.setValue(value != null && !value.isEmpty() ? value : scanner.nextLine());
        break;
    }
  }

  private void promptForValue(Command command, String value) {
      String response = "";
      while (!response.equalsIgnoreCase("Y") && !response.equalsIgnoreCase("N")) {
        if (!command.getValue().equals("null")){
          System.out.println("Already Data Exists, Replace with new value? (Y/N)");
          response = scanner.nextLine();
          if (response.equalsIgnoreCase("Y")) {
            System.out.println("Setting : ");
            command.setValue(value != null && !value.isEmpty() ? value : scanner.nextLine());
            break;
          } else if (response.equalsIgnoreCase("N")) {
            System.out.println("Operation Abandoned.");
            break;
          } else {
            System.out.println("Invalid input, please enter 'Y' for Yes or 'N' for No.");
          }
        } else {
          System.out.println("Setting : ");
          command.setValue(value != null && !value.isEmpty() ? value : scanner.nextLine());
        }
      }

  }
